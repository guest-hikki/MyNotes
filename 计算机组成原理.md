# 计算机组成原理

## 一、计算机系统的概述

### 1.1 - 计算机系统的概念与发展

1. 计算机系统 = 硬件 + 软件

   > 软件包括系统软件和应用软件
   >
   > ---
   >
   > **系统软件**：用来管理整个计算机系统
   >
   > ​	举例：操作系统、数据库管理系统、标准程序库、网络软件、语言处理程序、服务程序
   >
   > **应用软件**：按任务需要编制成的各种程序

2. 计算机硬件的发展

   > ![image-20211002153753876](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153753876.png)

3. 计算机软件的发展

   > 机器语言 → 汇编语言 → 编程语言

### 1.2.1 - 计算机硬件的基本组成

1. 早期的冯诺依曼机

   > 1. 硬件实现：
   >
   >    ![image-20211002153829598](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153829598.png)
   >
   >    > 图片中的实线表示数据线、虚线表示控制线和反馈线
   >
   > 2. 在计算机系统中，**软件和硬件在逻辑上是等效的**
   >
   >    例如：我们可以为一个运算专门设计一个电路设置一条指令来实现，也可以使用软件的方式执行多个指令来实现
   >
   > 3. 冯诺依曼计算机的特点：
   >
   >     > 1. 计算机有五大部分组成：运算器、控制器、存储器、输入设备与输出设备
   >     >
   >     >    > 运算器（ALU）：进行算数运算和逻辑运算
   >     >    >
   >     >    > 控制器（CU）：指挥控制程序的运行 —— 完成指令的执行，对指令之间的先后顺序进行控制
   >     >    >
   >     >    > 存储器：存放数据和程序
   >     >    >
   >     >    > 输入设备：将信息转换为机器能够识别的形式
   >     >    >
   >     >    > 输出设备：将机器运算的结果转换为人们熟悉的形式
   >     >
   >     > 2. 指令和数据以同等地位存于存储器，可按地址寻访
   >     >
   >     > 3. 指令和数据由二进制表示
   >     >
   >     > 4. 指令由操作码和地址码组成
   >     >
   >     > 5. 存储程序：**将指令以二进制代码的形式实现输入计算机的主存储器**，然后按其在存储器中的首地址一次执行指令，直到程序执行结束
   >     >
   >     > 6. ==以运算器为中心==：IO设备与存储器之间的数据传送通过运算器完成（而运算器的设计本来只是为了处理运算的，这就导致了效率的降低）

2. 现代计算机

   > ![image-20211002153902593](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153902593.png)
   >
   > 现代计算机：==以存储器为核心==
   >
   > ---
   >
   > 逻辑框图简化版：
   >
   > ![image-20211002153921370](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153921370.png)
   >
   > CPU = 运算器 + 控制器
   >
   > 主机 = CPU + 主存
   >
   > ---
   >
   > 区分主存和辅存：
   >
   > 1. 主存属于主机设备，辅存输入I/O设备
   > 2. 应用软件一般存储在辅存，只有运行的时候才将数据存放至主存。所以辅存属于I/O设备
   >
   > ![image-20211002153931324](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153931324.png)

### 1.2.2 - 硬件部件的讲解

1. <span id="存储器">主存储器</span>的基本组成

   > 1. 主存储器由**存储体**、MAR（存储**地址寄存器**）、MDR组成（存储数据**寄存器**）组成
   >
   > 2. MAR与MDR详解：
   >
   >    ![image-20211002153942955](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002153942955.png)
   >
   >    > CPU读取数据：CPU将所要读取数据的地址交给MAR，主存储器根据MAR保存的地址到存储体中取出数据，并将数据保存在MDR中，CPU再到MDR中取走数据
   >    >
   >    > ---
   >    >
   >    > CPU写入数据：CPU将要写入的数据的地址交给MAR，将要写入的数据交给MDR，主存储器根据MAR存储的地址将MDR中的数据保存至存储体中指定的位置
   >
   >    ~有些硬件会将MAR与MDR集成至CPU中~
   >
   > 3. 存储体详解：
   >
   >    > 1. 数据（指令或运算数据）在存储体内按地址存储
   >    >
   >    > 2. 存储体会被分割为一个个的**存储单元**，每个存储单元会存放一串**二进制代码**，且每个存储单元会对应一个从0开始的地址信息，这个信息就是MAR中保存的信息
   >    >
   >    >    > 存储字（word）：存储单元中存放的二进制代码
   >    >    >
   >    >    > 存储字长：存储字的字长（一般为2 | 4 | 8 | 16 | 32 | 64）
   >    >    >
   >    >    > 存储元：存储二进制的电子原件（利用电容原理），每个存储元可存储1bit
   >    >
   >    > 3. MAR指明了存储单元的地址，所以MAR的位数反映存储单元的个数 —— 如：4位表示存储体中有2^4^个存储单元
   >    >
   >    > 4. 从存储单元取出的数据要放到MDR中，所以MDR的二进制位数等于存储字长
   >    >
   >    > ---
   >    >
   >    > 区分字和字节：
   >    >
   >    > 1. 字节（Byte）：一个字节是8个比特（bit）位
   >    >
   >    >    > B：表示字节
   >    >    >
   >    >    > b：表示比特
   >    >
   >    > 2. 字（word）：一个字表示的比特（bit）位与计算机硬件设计（存储字长）有关

2. 运算器的基本组成

   > 1. 运算器由ACC（累加器）、MQ（乘商寄存器）、X（通用的操作数寄存器）、==ALU==（算数逻辑单元）组成
   >
   > 2. 功能介绍：
   >
   >    > ACC（累加器）：在加减运算时，用于存放操作数或运算结果
   >    >
   >    > MQ（乘商寄存器）：在乘除运算时，用于存放操作数或运算结果
   >    >
   >    > X（通用的操作数寄存器）【存在多个】：用于存放操作数
   >    >
   >    > ==ALU==（算数逻辑单元）：通过内部复杂的电路实现算数运算和逻辑运算
   >    >
   >    > > 在进行加法运算的时候，ACC中存入被加数，X中存放加数，ACC中存放运算结果
   >    > >
   >    > > 在进行乘法运算的时候，X中存放被乘数，MQ中存放乘数，ACC中存放运算结果
   >
   > ![image-20211003160918542](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003160918542.png)

3. 控制器的基本组成

   > 1. 控制器由==CU==（控制单元）、IR（指令寄存器）、PC（程序计数器）组成
   >
   > 2. 功能介绍：
   >
   >    > ==CU==（控制单元）：分析指令，给出控制信号
   >    >
   >    > IR（指令寄存器）：存放当前执行的指令
   >    >
   >    > PC（程序计数器）：存放一下条指令的地址，有自动加一的功能（我的理解：可以看作一个指针）
   >
   > 3. 完成一条指令的步骤：
   >
   >    > 1. 取指令：通过PC中存储的地址向主存储器获取指令（主存储器中存储的指令地址是连续的）
   >    > 2. 分析指令：通过IR保存获取到的指令，并使用CU进行分析
   >    > 3. 执行指令：CU进行分析后，控制其它的部件配合完成指令的操作
   >    >
   >    > ---
   >    >
   >    > 很多时候，也会将第一二步称作**取指**的阶段；第三步称作**执行**的阶段

4. 计算机的工作过程演示

   ~~~C
   int a=2, b=3, c=1, y=0;
   void main(){
       y=a*b+c; 
   }
   ~~~

   在此段代码编译过后，会将指令和数据存储至主存 —— 

   ![image-20211002154002190](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154002190.png)

   此时0\~4存储的是机器指令，而5\~8存储的是数据内容。且PC指向0号存储地址

   > 执行**第一条指令**的具体步骤：
   >
   > #初始状态：(PC)=0，指向此次需要指向的指令地址
   >
   > #1：(PC)→MAR，导致(MAR)=0
   >
   > #2：主存储器从存储体中获取(MAR)保存的地址上的数据
   >
   > #3：M(MAR)→MDR（将主存储器中MAR保存地址的内容存放之MDR中），导致(MDR)=**000001**0000000101
   >
   > #4：(MDR)→IR，导致(IR)=**000001**0000000101，且PC在此时自动加一，导致(PC)=1
   >
   > #5：OP(IR)→CU（指令的操作码送到CU），CU分析后得知，这是**取数**指令
   >
   > #6：Ad(IR)→MAR（指令的地址码送到MAR），导致(MAR)=5
   >
   > #7：主存储器从存储体中获取(MAR)保存的地址上的数据
   >
   > #8：M(MAR)→MDR，导致(MDR)=0000000000000010=2
   >
   > #9：(MDR)→ACC，导致(ACC)=0000000000000010=2
   >
   > > #1 \~ #4 ：取指令
   > >
   > > #5：分析指令
   > >
   > > #6 \~ #9：执行**取数**指令
   >
   > ![image-20211002154016071](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154016071.png)
   >
   > ---
   >
   > 执行**第二条指令**的具体步骤：
   >
   > #1：(PC)→MAR，导致(MAR)=1
   >
   > #3：M(MAR)→MDR，导致(MDR)=**000100**0000000110
   >
   > #4：(MDR)→IR，导致(IR)=**000100**0000000110，且PC在此时自动加一，导致(PC)=2
   >
   > #5：OP(IR)→CU，CU分析后得知，这是**乘法**指令（且此时a已经被保存到ACC中了）
   >
   > #6：Ad(IR)→MAR，导致(MAR)=6
   >
   > #8：M(MAR)→MDR，导致(MDR)=0000000000000011=3
   >
   > #9：(MDR)→MQ，导致(MQ)=0000000000000011=3
   >
   > #10：(ACC)→X，导致(X)=2
   >
   > #11：(MQ)*(X)→ACC，由ALU实现逻辑运算，导致(ACC)=6，如果乘积太大，则需要MQ辅助存储
   >
   > > #1 \~ #4 ：取指令
   > >
   > > #5：分析指令
   > >
   > > #6 \~ #11：执行**乘法**指令
   >
   > ![image-20211002154027462](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154027462.png)
   >
   > ---
   >
   > 执行**第三条指令**的具体步骤：
   >
   > #1：(PC)→MAR，导致(MAR)=2
   >
   > #3：M(MAR)→MDR，导致(MDR)=**000011**0000000111
   >
   > #4：(MDR)→IR，导致(IR)=**000011**0000000111，且PC在此时自动加一，导致(PC)=3
   >
   > #5：OP(IR)→CU，CU分析后得知，这是**加法**指令（且此时a*b已经被保存到ACC中了）
   >
   > #6：Ad(IR)→MAR，导致(MAR)=7
   >
   > #8：M(MAR)→MDR，导致(MDR)=0000000000000001=1
   >
   > #9：(MDR)→X，导致(X)=0000000000000001=1
   >
   > #10：(ACC)+(X)→ACC，导致(X)=7
   >
   > ---
   >
   > 执行**第四条指令**的具体步骤：
   >
   > #1：(PC)→MAR，导致(MAR)=3
   >
   > #3：M(MAR)→MDR，导致(MDR)=**000010**0000001000
   >
   > #4：(MDR)→IR，导致(IR)=**000010**0000001000，且PC在此时自动加一，导致(PC)=4
   >
   > #5：OP(IR)→CU，CU分析后得知，这是**存数**指令
   >
   > #6：Ad(IR)→MAR，导致(MAR)=8
   >
   > #8：ACC→MDR，导致(MDR)=7
   >
   > #9：存储器将MDR中的数据存放到MAR指定的地址，导致y=7
   >
   > ---
   >
   > 执行**第四条指令**的具体步骤：
   >
   > #1：(PC)→MAR，导致(MAR)=4
   >
   > #3：M(MAR)→MDR，导致(MDR)=**000110**0000000000
   >
   > #4：(MDR)→IR，导致(IR)=**000110**0000000000，且PC在此时自动加一，导致(PC)=5
   >
   > #5：OP(IR)→CU，CU分析后得知，这是**停机**指令，接下来执行操作系统相关指令进行停机

### 1.2.3 - 计算机系统的层次结构

1. 从编程人员和硬件设计人员的视角进行划分

   ![image-20211002154044773](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154044773.png)

2. 三种级别的语言

   ![image-20211002154105039](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154105039.png)

   > 编译程序：将高级语言编写的源程序全部语句**一次全部翻译**为机器语言或汇编语言程序
   >
   > 解释程序：将源程序**逐句翻译**为对应的机器语言的语句并**立即执行**
   >
   > 汇编程序：将汇编语言翻译为机器语言

### 1.3 - 计算机的性能指标

* [存储器](#存储器)的性能指标：容量

  > 总容量 = 存储单元个数 * 存储字长（bit）
  >
  > 其中MAR位数可以反应存储单元的最大个数，MDR位数可以反应存储字长（即每个存储单元的大小）

  例：MAR为32位，MDR为8位

  ​		→ 总容量 = 2^32^ * 8 bit = 4GB

  > 8b = 1B
  >
  > 存储容量、文件大小类单位介绍 → 	2^10^：K	|	2^20^：M	|	2^30^：G	|	2^40^：T

* **CPU性能指标**：CPU主频、CPI

  > **CPU主频**：CPU内数字脉冲信号震荡的频率（单位：HZ → 每秒钟的脉冲信号数）
  >
  > * CPU时钟周期：每个脉冲信号的时间（单位：微秒，纳秒）
  >
  > * CPU主频（时钟频率） = 1 / CPU时钟周期
  >
  > ---
  >
  > **CPI**：执行一条指令所需的时钟周期数
  >
  > * 不同的指令CPI可能不同，甚至相同的指令，CPI也可能发生变化
  >
  > ---
  >
  > CPU的执行时间（执行整个程序的耗时） = 指令条数 * 指令CPI * CPU时钟周期
  >
  > **IPS**：每秒执行多少条指令 = CPU主频 / 主频CPI
  >
  > **FLOPS**：每秒执行多少次浮点运算
  >
  > 为了方便表示，我们通常会在IPS与FLOPS之前添加数量单位
  >
  > 频率、速率类单位介绍 → 	2^3^：K（Kilo）	|	2^6^：M（Million）	|	2^9^：G（Giga）	|	2^12^：T（Tera）
  >
  > ---
  >
  > ~~~text
  > F&Q
  > Q1：主频高的CPU一定比主频低的CPU快吗？
  > A1：不一定，因为平均CPI可能不一样
  > ---
  > Q2：IPS高的CPU性能一定好吗？
  > A2：不一定，还需要看指令系统
  > ~~~

* 系统整体的性能指标

  > **数据通路带宽**：数据总线一次所能并行传送信息的位数
  >
  > > 各硬件通过数据总线传输数据
  >
  > **吞吐量**：系统在单位时间内才处理请求的数量
  >
  > > 取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及结果能多快地从内存送给外部设备。这其中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期
  >
  > **响应时间**：从用户发送一个请求，到系统对该请求做出相应并获取它所需要的结果的等待时间
  >
  > ---
  >
  > 基准程序：用来测量计算机处理速度的一种实用程序（即跑分软件）

## 二、数据的表示与运算

### 2.1.1 - 进位计数制

* 任意进制转十进制

  ![image-20211002154119890](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154119890.png)

* 二进制转八进制或十六进制

  ![image-20211002154134354](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154134354.png)

* 十进制转任意进制

  ![image-20211002154146116](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154146116.png)

  > 整数部分的处理：除基取余法
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154153041.png" alt="image-20211002154153041" style="zoom:67%;" />
  >
  > 小数部分的处理：乘积取整法（有可能遇到无法精确表示的情况）
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154205970.png" alt="image-20211002154205970" style="zoom: 67%;" />

* 真值与机器数

  > 真值：符合人类习惯的数字
  >
  > 机器数：数字实际上存储到机器内的形式，正负号需要被“数字化”

### 2.1.2 - BCD码

* BCD码：（Binary-Coded Decimal）使用二进制编码的十进制

  > 使四位二进制数表示一位十进制数

* 分类：

  > 8421码（有权码）：
  >
  > ![image-20211002154227995](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154227995.png)
  >
  > 余3码（无权码）：
  >
  > > 余3码 = 8421码 + (0011)~2~
  >
  > ![image-20211002154235300](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154235300.png)
  >
  > 2421码（有权码）：0\~4范围内第一个数都是0，5\~9范围内第一个数都是1
  >
  > ![image-20211002154251456](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154251456.png)

* 8421码的加法计算

  > 若运算的结果小于9，即在映射范围之内，则无需做任何改变
  >
  > 若运算的结果大于9（10~18），则需要加上0110（6）进行修正，即强制向高位进一
  >
  > ![image-20211002154304012](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002154304012.png)

### 2.1.3 - 字符与字符串

* ASCII码（八位二进制）

  ![image-20211002221925198](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002221925198.png)

  > * 可印刷字符：
  >   * 数字：48（0011**0000**） ~   57（0011**1001**）
  >   * 大写字母：65（010**00001**）~  90（010**11010**）
  >   * 小写字母：97（011**00001**）~  122（011**11010**）
  > * 其余字符：用于控制和通信的字符

* 汉字编码方案

  > * 汉字的存储编码：以GB2312-80为例
  >
  >   ![image-20211002223237799](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002223237799.png)
  >
  >   > 为了避免与ASCII设计的字符发生冲突，国际码和汉字内码分别为区位码的每一个数组下标加上了对应的值。
  >   >
  >   > 这里想一想宽字节注入的绕过方式就明白了
  >
  > * 汉字的输入编码：五笔、拼音
  >
  > * 汉字的输出编码：点阵图

* 字符串的存储：

  > 1. 字符串是从低地址到高地址逐个存储字符，常采用`\0`作为结尾的标志
  >
  > 2. 对于多字节的数据（如汉字），可以采取大/小端存储模式
  >
  >    > * 大端模式：将数据的最高有效字节存放在低地址单元中
  >    > * 小端模式：将数据的最高有效字节存放咋高地址单元中
  >    >
  >    > ![image-20211002224203821](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002224203821.png)

### 2.1.4 - 奇偶校验码

1. 校验原理介绍：

   > * 概念补充：
   >
   >   1. 位错误：在数据传输的时候，0变为1，1变为0
   >
   >   2. 码字：由若干位代码组成的一个字
   >
   >   3. 码字间的距离：两个码字不同位数的个数
   >
   >   4. 码距（d）：一种编码方案，可能有若干个合法的码字，各合法码字间的最小举例就是码距
   >
   >      ![image-20211002225155225](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002225155225.png)
   >
   > * 当d=1时，该编码无检错能力。因为当有一位发生位错误后，其仍是合法码字
   >
   >   当d=2时，该编码有检错能力。因为当有一位发生位错误后，将会变为非法码字
   >
   >   当d>=3时，若设计合理，可能具有检错和纠错能力

2. 奇偶校验码：

   > * 校验原理：在信息位之前添加奇偶校验位，通过校验位来设置整个校验码“1”的个数固定为基数或偶数
   >
   >   ![image-20211002225739901](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002225739901.png)
   >
   > * 偶校验的硬件实现
   >
   >   * 获取偶校验位：对有效信息位的所有信息进行逐位异或运算，将得到的结果填入偶校验位
   >
   >     > 异或为1，说明两个数据不一致，说明1的数量为奇数，需要再添加1
   >     >
   >     > 异或为0，说明两个数据一致，说明1的数量为偶数，则添加0
   >
   >   * 进行偶校验：对奇偶校验码的所有位进行异或运算，如果结果为1，则说明1的数量为奇数，说明结果出错

### 2.1.5 - 海明校验码

1. 设计思路：将有效信息位分组进行偶校验 → 需要设计多个校验位

2. 海明校验码的使用：

   > 1. **确定校验位个数**：通过n求k
   >
   >    > 设有n个有效信息位，有k个校验位 → 需要校验的状态数：n + k + 1【n+k每一位都可能出错[^注2.1.5-1]+正确的状态】
   >    >
   >    > k个校验位 → 最多表示2^k^种状态
   >    >
   >    > 所以有：==**2^k^ ≥ n + k + 1**==
   >
   >    ![image-20211002233552113](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002233552113.png)
   >
   > 2. **确定校验位分布**：校验位P~i~放在海明码号位2^i-1^的位置上
   >
   >    > 我们通常将校验位用P表示，把有效信息位用D表示，把海明码用H表示
   >    >
   >    > 在获取到校验位之后，我们将有效信息位按顺序放到其余位置上
   >
   >    ![image-20211002233617936](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002233617936.png)
   >
   > 3. **求校验位**：将所有信息位用二进制位表示，获取对应位上为1的数据的偶校验位将其赋给对应的校验位即可
   >
   >    ![image-20211002233029793](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002233029793.png)
   >
   > 4. **纠错**：对各个分组进行偶校验，若都为0，则说明无错误；若有一组或几组结果为1，则可以根据结果排列的二进制数确定出错的位数
   >
   >    > 原理：<img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002233712472.png" alt="image-20211002233712472" style="zoom:67%;" />
   >
   >    ![image-20211002233826136](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002233826136.png)

3. 补充说明：

   > 1. 之前有提到，海明码能够准确地处理一个bit位跳变的情况，但是无法处理多个bit位跳变的情况。为了解决这个问题，我们通常对数据**加上全校验位**，对整体进行偶校验
   >
   >    ![image-20211002234330304](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211002234330304.png)
   >
   > 2. 海明码具有一个bit位的纠错能力，具有2个bit位的检错能力

[^注2.1.5-1]:单独使用海明校验码之内校验出一位出错的情况，所以此处不考虑多位出错的情况

### 2.1.6 - 循环冗余校验码（CRC码）

1. 基本思想：

   > ![image-20211003000216840](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003000216840.png)
   >
   > 1. 数据发送方和接收方约定一个“除数”
   > 2. 将K位信息位+R位校验位作为“被除数”
   > 3. 通过调整校验位的值保证除法的余数为0，通过检查余数进行纠错

2. **除数**的获取：通过事先约定完成的生成多项式来获取

   > 将多项式的系数转换为二进制数，这个二进制数就是除数

3. **校验位**的计算：

   > 1. 判断校验位的位数：
   >
   >    校验位位数R = 生成多项式的最高次幂
   >
   > 2. 将信息位左移R位，低位补0
   >
   > 3. 对移位后的信息码，用除数进行==模2除法==，产生余数，余数就是校验位的信息
   >
   >    ~~~text
   >    模2减：异或
   >    ---
   >    模2除法步骤：
   >    1. 类似于除法，但是进行模2除的时候，不会比较除数和被除数的大小，而是看被除数的首位是否为1
   >    	> 若为1，则商1
   >    	> 若不为1，则商0
   >    2. 在求完商之后，将结果进行模2减运算（异或），异或的结果首尾一定是0，舍弃掉这个0号位
   >    3. 落数，再上商
   >    ~~~
   >
   >    ![image-20211003002319570](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003002319570.png)

4. 校验与纠错

   > CRC的校验功能：
   >
   > 若余数 = 0，则表示没有出错
   >
   > 若余数不为0，则代表发生错误
   >
   > ---
   >
   > CRC码的纠错功能：
   >
   > 若CRC码有K个信息位，R个校验位，若生成多项式选择得当，且2^R^ ≥ K + R + 1，则CRC码可以纠正1位错
   >
   > 但是CRC码通常用于计算机网络的数据传输，通常K会远大于R，所以**一般CRC码只用来检错**而不是纠错

### 2.2.1 - 定点数的表示

1. 定点数：小数点位置保持不变			—— 常规计数	

   浮点数：小数点位置不固定				—— 科学计数法

2. 分类：

   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003102439958.png" alt="image-20211003102439958" style="zoom:67%;" />

3. 无符号数的表示：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值（无符号数只有整数）

   > **表示范围**：
   >
   > ==n位的无符号数表示范围为0 ~ 2^n^-1==
   >
   > ![image-20211003102759846](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003102759846.png)

4. 定点数的原码表示：

   > **原码**：用定点数的尾数表示真值的绝对值，符号位**0代表正，1代表负**
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003103239277.png" alt="image-20211003103239277" style="zoom: 67%;" />
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003103301763.png" alt="image-20211003103301763" style="zoom:67%;" />
   >
   > 可见：若机器字长为n+1位，则尾数占n位，符号位只占1位
   >
   > ---
   >
   > **表示范围**：
   >
   > 若机器字长为n+1，则尾数占n位
   >
   > * 原码整数的表示范围：- (2^n^ - 1) ~ 2^n^ - 1
   > * 原码小数的表示范围：- (1 - 2^-n^) ~ 1 - 2^-n^
   > * 真值0有+0和-0两种表示形式

5. 定点数的反码表示：反码为原码转换为补码的一个中间状态，没有实际作用

   > **反码**：若符号位为0，则反码与原码相同；若符号位为1，则反码为**原码==数值位==全部取反**得到
   >
   > ---
   >
   > 反码0的表示：
   >
   > +0 ： 00000000
   >
   > -0  ：11111111

6. 定点数的补码表示：

   > **补码**：若符号位为0，则补码与原码相同；若符号位为1，则补码为**反码+1**
   >
   > ---
   >
   > 补码0的表示：
   >
   > +0 ：00000000
   >
   > -0  ：00000000（向最高位进的1被舍弃）
   >
   > 所以可见补码0只有一种表示形式 —— 00000000
   >
   > 那么补码就会有一个空余的补码 —— 10000000，我们规定其用来表示2^-7^或-1
   >
   > 可见，补码整数的表示范围为：- (2^n^) ~ 2^n^ - 1
   >
   > ​			补码小数的表示范围为：-1 ~ 1 - 2^-n^
   >
   > ---
   >
   > 通过补码求原码的方法：若为符号位为0，则不变；若符号位为1，则数值位全部取反再+1
   >
   > 通过[x]~补~快速求[-x]~补~的方法：将符号位和数值位全部取反，然后末尾位+1

   > **重要**：补码的特性
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150304562.png" alt="image-20211003150304562" style="zoom:50%;" />
   >
   > 补码以从右往左数第一个1的左边为分界线 
   >
   > 位于左侧的数据同反码，位于右侧的数据同原码

7. 定点整数的移码表示：

   > **移码**：在补码的基础上将符号位取反（注意：移码只能用于表示整数）
   >
   > 真实定义：移码 = 真值 + 偏置值
   >
   > ![image-20211003233416977](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003233416977.png)
   >
   > ---
   >
   > 移码的表示范围：与补码一致
   >
   > 移码的作用：可以让计算机很方便地对比真值的大小
   >

### 2.2.2 - 补码的作用

1. 模运算：

   > * 我们将求商取余的运算称作模运算。我们把模运算结果相同的一类数称作互为补数
   >
   > * 若两个数互为补数，那么加上它们中的任意一个再取模，得到的结果是等价的
   >
   > * 在(mod m)的条件下，若能找到负数的补数，那么可以用正数的加法来代替减法
   >
   >   > 如 `(a + b) mod m` ，若`b`的补数为`c`，则`(a + b) mod m `等价于` (a + c)mod m`（此时b为负数，c为正数）
   >   >
   >   > ---
   >   >
   >   > 求`c`的方法：`m - |b| = c`

2. 补码的作用：使用补码可以将减法操作转换为等价的加法，使ALU中无需集成减法器。

   > * 因为在计算机硬件内部，对数据有位数的限制，超过位数的数据将会被舍弃，所以天然的就有模运算的性质
   >
   >   > 如：计算机用8位存储数据 → 存储的数据都会进行mod 2^8^ 的操作
   >
   > * `b(负数)`的补数就是它的补码，我们可以利用补码让减法操作转换为加法操作
   >
   >   > 计算**a + b**只需要计算**a + `b的补码`**即可（注意：符号位也需要参与运算）
   >   >
   >   > ---
   >   >
   >   > 补码的原理：符号位不变
   >   >
   >   > 我们知道**模 - b的绝对值 = b的补数**，有
   >   >
   >   > 1. b的绝对值 = b的数值位
   >   > 2. b的数值位 + b的数值位取反 = b的数据位全为1
   >   > 3. b的数值位全为1 + 1 = 模
   >   >
   >   > 所以b（负数）的补码 = b的绝对值(数值位) 取反再加一 
   
3. 负数补码的快速计算：从左往右寻找补码的第一个1，在1的左侧划一个分界线，将分界线左边的数值全部取反

   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150304562.png" alt="image-20211003150304562" style="zoom:50%;" />

### 2.2.3 - 移位运算

1. 算数移位

   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150655732.png" alt="image-20211003150655732" style="zoom:67%;" />
   >
   > * 原码的算数移位：符号位保持不变，数值位进行移位，缺位补0，进位舍弃
   >
   >   > 若舍弃的位 ≠ 0，则会丢失精度（右移）或造成严重误差（左移）
   >
   > * 反码的算数移位：
   >
   >   * 正数：与原码相同
   >   * 负数：缺位补1
   >
   > * 补码的算数移位：
   >
   >   * 正数：与原码相同
   >
   >   * 负数：左移补0，右移补1
   >
   >     <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150304562.png" alt="image-20211003150304562" style="zoom:50%;" />
   >
   > ---
   >
   > 左移相当于✖2	|    右移相当于➗2 
   >
   > ![image-20211003150507679](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150507679.png)

2. 逻辑移位：

   > 逻辑右移：高位补0，低位舍弃
   >
   > 逻辑左移：低位补0，高位舍弃
   >
   > ---
   >
   > 应用举例：将RGB值拼接为3B的数据 → 将R数据导入，左移16位；将G数据导入，左移8位；将B数据导入
   >
   > ![image-20211003150957286](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003150957286.png)

3. 循环移位：

   > 不带进位位的循环移位：将移出的数据补到空余数据处
   >
   > 带进位位的循环移位：将移出的数据放到进位位中，将进位位的数据放到空余数据中
   >
   > ![image-20211003151235360](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003151235360.png)
   >
   > ---
   >
   > 常见作用：将高字节与低字节进行调换

### 2.2.4 - 加减运算

1. 原码的加法运算：

   > 正 + 正 / 负 + 负 → 绝对值相加，符号保持不变
   >
   > 正 + 负 / 负 + 正 → 绝对值为大值 - 小值，符号与大值保持一致

   > 计算机中通常是使用补码进行加减运算：
   >
   > * 加法运算：将两个数的补码相加，然后将得到的补码转换为原码[^注2.2.4-1]
   > * 减法运算：将减数的补码转换为减数取反后的补码[^注2.2.4-2]，在将被减数的补码与减数取反后的补码相加，最后将得到的补码转换为原码
   >
   > ![image-20211003152911922](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003152911922.png)

   [^注2.2.4-1]:补码转原码：符号位不变，数值位取反+1
   [^注2.2.4-2]:通过[x]~补~快速求[-x]~补~的方法：将符号位和数值位全部取反，然后末尾位+1

2. 原码的减法运算：将减数的符号取反，转换为加法运算

3. 溢出判断：

   > ![image-20211003153116413](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003153116413.png)
   >
   > * 上溢：正数 + 正数 = 负数
   > * 下溢：负数 + 负数 = 正数
   >
   > ---
   >
   > 判断方法一：采用溢出逻辑表达式
   >
   > 设有 A + B = S，有A~s~表示A的符号，B~s~表示B的符号，S~s~表示S的符号
   >
   > ![image-20211003153906787](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003153906787.png)
   >
   > ---
   >
   > 判断方法二：采用进位判断
   >
   > |      | 符号位进位C~s~ | 最高数值位进位C~1~ |
   > | :--: | :------------: | :----------------: |
   > | 上溢 |       0        |         1          |
   > | 下溢 |       1        |         0          |
   >
   > 即C~s~与C~1~不同时，则有溢出 → V = C~s~⊕C~1~
   >
   > ---
   >
   > 判断方法三：采用双符号位 
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003154628413.png" alt="image-20211003154628413" style="zoom:50%;" />
   >
   > 正数符号位采用00，负数符号位采用11 → 第一个符号位表示正确运算的符号位，第二个符号位表示运算结果的符号位
   >
   > 01 → 上溢 | 10 → 下溢

4. 符号扩展：

   > 溢出是因为产生了数值最高位的进位 —— 解决方案：<span id="符号扩展">符号扩展</span>（如：1B扩展为2B）
   >
   > ![image-20211003154940364](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003154940364.png)

### 2.2.5.1 - 原码乘法运算

1. 乘法运算的实现思想：类比于手算方法

   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003161022875.png" style="zoom:50%;" />

2. 运算器实现乘法运算：

    ![image-20211003161147238](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003161147238.png)

   ![image-20211003161316297](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003161316297.png)

   > 1. 运算开始前，将ACC置零。被乘数保存在X里面，而乘数保存在MQ里面
   >
   > 2. 若MQ数据的最低位为0，则不对ACC中数据进行操作
   >
   >    若MQ数据的最低位为1，则ACC中需要加上被乘数（利用ALU中的加法电路完成）【(ACC) + (X) → (ACC) 】
   >
   > 3. 将ACC逻辑右移，最高位使用0补全；MQ进行逻辑右移，最高位使用ACC移出的最低位补全
   >
   > 4. 继续进行2、3步操作，直到MQ的最低位为乘数的符号位停止【移位乘数数值位的次数】，将ACC中数据于MQ中除最低位数据拼接就是积的值
   >
   > 5. 处理符号位：将两个数的符号位进行异或运算然后将结果替换积的符号位即可
   >
   > 6. 若为定点小数，则将小数点标在符号位的后面；而若是定点整数，则可以在符号位后后面使用逗号标记

3. 实例演示：

   ![image-20211003164746649](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003164746649.png)

   高位部分积：ACC		|		低位部分积/乘数：MQ

### 2.2.5.2 - 补码乘法运算

1. 运算器实现：

   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003165711173.png" alt="image-20211003165711173" style="zoom:67%;" />

2. 运算方法：

   ![image-20211003170010707](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003170010707.png)

3. 手算实例：

   ![image-20211003170706543](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003170706543.png)

### 2.2.6.1 - 原码除法运算

> 此处介绍定点小数的除法运算，所以得到的结果也必须是定点小数，则除数必须要大于被除数

1. 恢复余数法：

   > * 运算器的存储数据：
   >
   >   ![image-20211003200015769](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003200015769.png)
   >
   >   ACC：一开始存储被除数，之后存储余数
   >
   >   通用寄存器X：存储除数
   >
   >   MQ：存储商
   >
   > * 运算器实现除法运算：
   >
   >   > 1. 将被除数存储到ACC中，除数存储到X中，MQ则置0
   >   >
   >   > 2. 将MQ的最后一位设置为1，然后将ACC中的数据减去X中的数据（被除数 - 除数 * 1），并将数据保存至ACC中
   >   >
   >   >    > (ACC) + [-|y|]~补~ → ACC
   >   >
   >   > 3. 若ACC中保存的数据符号位为0，则说明应该商1，不进行任何操作
   >   >
   >   >    若ACC中保存的数据符号位为1，则说明【被除数 - 除数 * 1】小于0，则MQ的最后一位应该设置为0，并恢复余数，即应该让ACC中的数据加上之前减去的除数
   >   >
   >   >    > 若ACC中的数据符号位为1，则(ACC) + [|y|]~补~ → ACC
   >   >
   >   > 4. 将MQ的内容逻辑左移，空余部分用0填补；将ACC的内容逻辑左移，空余部分用MQ移出的最高位数据填补
   >   >
   >   > 5. 循环运行2、3、4步，循环次数为数值字长（且循环最后一步，余数不左移）
   >   >
   >   > 6. 处理符号位：将被除数和除数的符号位异或**（符号位单独处理）**
   >
   > * 手算方法：
   >
   >   ![image-20211003201752364](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003201752364.png)

2. 加减交替法：

   > 1. 对恢复余数法的优化
   >
   >    > 设被除数为a，而除数为b
   >    >
   >    > 恢复余数法在每次【被除数 - 除数 * 1】小于0之后都需要**恢复余数，再左移，再减去除数**
   >    >
   >    > a → 减去除数 → a - b → 若a - b < 0，则恢复余数 → a - b + b = a → 余数左移 → a * 2  → 减去除数 → a * 2 - b
   >    >
   >    > 若【被除数 - 除数 * 1】小于0之后，不恢复余数，而是在**下一步左移加除数**，也可完成操作
   >    >
   >    > a → 减去除数 → a - b → 若a - b < 0，则进行左移减除数 → 左移 → 2 * a - 2 * b → 加除数 → a * 2 - b
   >    >
   >    > ---
   >    >
   >    > 注意：在最后一步得到的余数为负数，需要使用恢复余数法的方法将余数恢复为原样
   >
   > 2. 手算方法：
   >
   >    ![image-20211003203350758](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003203350758.png)

### 2.2.6.2 - 补码除法运算

1. 补码加减交替法的手算实现：符号位参与运算，且采用双符号位

   > 1. 若除数与被除数同号，余数 = 被除数 - 除数
   >
   >    若除数与被除数异号，余数 = 被除数 + 除数
   >
   > 2. 若余数和除数同号，则商1，余数左移一位减去除数
   >
   >    若余数和除数异号，则商0，余数左移一位加上除数
   >
   > 3. 循环1、2步n次（n为数值字长），且商末位恒置为1

2. 与原码加减交替法区别

   ![image-20211003205414852](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003205414852.png)

3. 手算实例：

   ![image-20211003205501293](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003205501293.png)

### 2.2.7 - 强制类型转换

>  C语言中的定点整数是用补码存储的

* 定点整数（int）转换为无符号定点整数（unsigned int）：不改变数据内容，但是改变解释方式

* 长整型（int）转换为短整型（short）：高位截断，保留低位

* 短整型（short）转换为长整型（int）：详见[符号扩展](#符号扩展)中的补码扩展

### 2.2.8 - 数据的存储和排列

* <span id="大小端模式">大小端模式</span>

  > 多字节数据在内存中一定是占连续的几个字节的，在字节在内存中的排列方式不同，我们有两种在内存中排列多字节数据的方式
  >
  > * 多字节数据：其最高有效字节是在左侧，而最低有效字节在右侧
  >
  >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003211715258.png" alt="image-20211003211715258" style="zoom:67%;" />
  >
  > * 内存中的低地址部分在左侧，而高地址部分在右侧，且内存的读取是从低地址部分到高地址部分来读取的
  >
  > ---
  >
  > ![image-20211003211943163](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003211943163.png)
  >
  > 大端模式（便于人类阅读）：将数据的最高有效字节存储在低地址部分
  >
  > 小端模式（便于机器读取）：将数据的最低有效字节存储在低地址部分

* 边界对齐

  > 现代计算机通常是按照字节编址，即每个字节对应一个地址
  >
  > 而通常计算机都支持按字、半字、字节寻址，且每次访存读取的内容只能读取1个字
  >
  > （假设存储字长为32位，则一个字=32bit，半字=16bit，1B=8bit）
  >
  > ---
  >
  > ![image-20211003212505987](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003212505987.png)
  >
  > 边界对齐方式相当于牺牲空间换取读取速度的策略

### 2.3.1 - 浮点数的表示

1. 浮点数的表示：可以类比于科学计数法（回想一下C语言的E）

   > +302657264526
   >
   > 科学计数法：3.026 * 10^11^ = 3.026E+11
   >
   > ---
   >
   > 1,1100.101
   >
   > 浮点数表示：0,100;1.110

   > 浮点数：
   >
   > ![image-20211003215232929](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003215232929.png)
   >
   > 阶码：常用补码或移码表示**定点整数**
   >
   > 尾数：常用原码或补码表示**定点小数**，尾数的数值部分的位数n代表浮点数的精度
   >
   > 浮点数的真值：N = r^E^ * M（N代表真值 | r代表阶码的底，通常为2 | E代表阶码 | M代表尾数）
   >
   > ---
   >
   > 例题：
   >
   > a的阶码、尾数均用补码表示，求a的真值。a = 0,01;1.1001
   >
   > a的阶码：+1 ，a的尾数：-0.0111，a的真值：-0.111

2. 浮点数尾数的规格化：同样类比科学计数法

   > 179.12E+5 → 1.7912E+7  	||		0.00125E-2 → 1.25E-5
   >
   > 科学计数法的规格化需要保证个位数为最高位且不为0
   >
   > ---
   >
   > 同理：规格化浮点数需要保证尾数的最高位数值必须是一个有效值
   >
   > ![image-20211003220626417](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003220626417.png)

   > <span id="规格化">规格化</span>的手法：
   >
   > * 左规：当浮点数运算的结果为非规格化时，要进行规格化处理，将尾数算数左移一位，阶码减1
   >
   >   b = 2^2^ * (+0.01001) = 2^1^ * (+0.10010)
   >
   > * 右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1
   >
   >   a = 010;00.1100	| 	b = 010;00.1000 	求a+b
   >
   >   a + b = 2^2^ * (00.1100)  + 2^2^*(00.1000)
   >
   >   ​		  = 2^2^ * (00.1100 + 00.1000)
   >
   >   ​		  = 2^2^ * (01.0100)		【右规】
   >
   >   ​		  = 2^3^ * (00.1010)
   >
   >   > 采用双符号位可以挽救溢出

3. 浮点数的表示范围（了解）：

   ![image-20211003221521200](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003221521200.png)

### 2.3.2 - IEEE 754

> 读作：I triple E 754，是一种浮点数表示的统一规则

* IEEE 754标准介绍

  ![image-20211003235202199](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003235202199.png)

  ![image-20211003235658397](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003235658397.png)

  > float类型的有效位为24位，因为数值位默认隐含了一个最高位1
  >
  > ---
  >
  > 以8位阶码为例 —— 阶码全1和全0会被用作特殊用途，所以8位阶码的正常范围应该是【-126 ~ 127】
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211003235859074.png" alt="image-20211003235859074" style="zoom:50%;" />
  >
  > 127D = 111 1111
  >
  > 1023D = 11 1111 1111

* 相关换算

  > s为数符，M为尾数数值位，E为阶码部分
  >
  > 阶码真值 = 移码 - 偏移量
  >
  > ---
  >
  > 规格化的短浮点数真值：(-1)^s^ * 1.M * 2^E-127^
  >
  > 规格化的长浮点数真值：(-1)^s^ * 1.M * 2^E-1023^
  >
  > ![image-20211004001437743](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004001437743.png)

  > 实例：
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004000659249.png" alt="image-20211004000659249" style="zoom:67%;" />
  >
  > ---
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004000808789.png" alt="image-20211004000808789" style="zoom:67%;" />

* 表示范围

  > 当阶码为-126 ~ 127的范围内时：
  >
  > ![image-20211004001046522](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004001046522.png)
  >
  > 当阶码全为0或全为1时，则有特殊含义
  >
  > ![image-20211004001310682](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004001310682.png)

### 2.3.3 - 浮点数的运算

1. 加减运算：

   > 0. 转换格式：将题中数据转换为相应格式的二进制浮点数表示
   >
   > 1. 对阶：阶数小的向阶数大的对齐，阶数变大相当于将尾数右移（补1）
   >
   >    > 1. 求阶差
   >    > 2. 对阶
   >
   > 2. 尾数加减
   >
   > 3. [规格化](#规格化)
   >
   > 4. 舍入
   >
   >    > * 0舍1入法：尾数右移后，若舍弃的是0，则不进行操作；若舍弃的是1，则在尾数末位加1。若加1又造成了溢出，则还需要进行一次右规
   >    > * 恒置1法：尾数右移时，不管丢弃的是什么值，右移后的尾数末位恒置为1
   >
   > 5. 判溢出：看阶码的两个符号位是否相同

   ![image-20211004095731392](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004095731392.png)

2. 浮点数的强制类型转换：

   > 一般考查的都是32位的机器

   ![image-20211004095127983](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004095127983.png)

   无精度损失和溢出的强制类型转化：

   * char → int → long → double
   * float → double

   ---

   最长考的强制类型转换 —— int与float

   > int与float均为32位：
   >
   > int：1位符号位 + 31位有效数值位
   >
   > float：1位符号位 + 8位阶码 + 23位尾数（实际有效数值有24位）

   int → float：损失精度

   float → int：溢出（float表示数值太大）或损失精度（小数部分被舍弃）

### 2.4.1 - 常用元器件

* ALU（算数逻辑单元）

  <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004101704581.png" alt="image-20211004101704581" style="zoom:67%;" />

* 用门电路求偶校验

  1. 求偶校验的原理：将所有数据异或

  2. 电路实现：

     <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004101833280.png" alt="image-20211004101833280" style="zoom:50%;" />

* 全加器：

  > A~i~：被加数的第i位数据	B~i~：加数的第i位数据	C~i~：当前运算数据的进位	C~i-1~：上一步运算数据的进位	S~i~：当前位运算结果
  >
  > ---
  >
  > S~i~ = A~i~ ⊕ B~i~ ⊕ C~i-1~
  >
  > C~i~ = A~i~B~i~ + (A~i~ ⊕ B~i~)C~i-1~
  >
  > ---
  >
  > 一位全加器：
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004102319597.png" alt="image-20211004102319597" style="zoom: 67%;" />
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004102341914.png" alt="image-20211004102341914" style="zoom: 67%;" />
  >
  > **串行加法器**：如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004102417082.png" alt="image-20211004102417082" style="zoom: 67%;" />
  >
  > **串行进位的并行加法器**：每一级的进位依赖于前一级的进位，进位信号是逐级形成的
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/image-20211004102544383.png" alt="image-20211004102544383" style="zoom:67%;" />

  > 全加器的优化：
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041118570.png" alt="image-20211004111825529" style="zoom: 67%;" />
  >
  > 所以：第 i 位向更高位的进位C~i~可以根据**被加数、加数的 1~i 位 与C~0~**确定，而这三个参数都是一开始就能够确定的值
  >
  > ---
  >
  > 我们来简化一下表达式 —— 设G~i~ = A~i~B~i~，P~i~ = A~i~ ⊕ B~i~（把G~i~称为进位产生函数，把P~i~称为进位传递函数）
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041131533.png" alt="image-20211004113106488" style="zoom:67%;" />
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041122848.png" alt="image-20211004112259806" style="zoom:67%;" />
  >
  > 由表达式可知：G~i~与P~i~在计算C~i~与其之后的进位中都会用到，所以我们可以设计如下电路
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041127087.png" alt="image-20211004112717041" style="zoom:80%;" />
  >
  > 我们把这种加法器称为并行进位的并行加法器：各级进位信号同时形成
  >
  > 而因为硬件的限制（电路的复杂程度），我们通常会到C~4~时截止，实现4bit数据的并行处理
  >
  > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041132048.png" alt="image-20211004113201005" style="zoom: 67%;" />
  >
  > ---
  >
  > 在得到4位CLA加法器之后，我们又可以将它像串行进位的并行加法器一样排列，形成**组内并行、组间串行**的进位方式
  >
  > ![image-20211004113442117](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041134162.png)
  >
  > 而这样又会产生于串行进位的并行加法器一样的问题 —— 进位信号是逐级形成的
  >
  > 为了解决这个问题，我们来看一下组内进位的最后一组表达式 与第一组表达式的对比
  >
  > C~4~ = G~4~ + P~4~G~3~ + P~4~P~3~G~2~ +  P~4~P~3~P~2~G~1~ +P~4~P~3~P~2~P~1~C~0~
  >
  > C~1~ = G~1~ + P~1~C~0~
  >
  > 可以很简单的看出二者的相似之处
  >
  > > 我们可以记G~1~^*^ = G~4~ + P~4~G~3~ + P~4~P~3~G~2~ +  P~4~P~3~P~2~G~1~ | P~1~^*^ = P~4~P~3~P~2~P~1~
  > >
  > > 有C~4~ = G~1~^*^ + P~1~^*^C~0~ ，我们把G~1~^*^ 称为组进位产生函数，把P~1~^*^称为组进位传递函数
  > >
  > > ==核心特性：组进位产生函数和组进位传递函数都可以通过输入位来直接得到==
  >
  > 所以有组内进位信号：
  >
  > ![image-20211004114422345](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041144385.png)
  >
  > 所以我们只要将组进位产生函数和组进位传递函数作为4位CLA加法器的输入，那么4位CLA加法器就可以帮助我们完成C~4~ + C~8~ + C~12~ + C~16~的运算，所以可以改进一下刚才得到的组内并行、组间串行的进位方式，变为**组内并行，组间并行**的进位方式
  >
  > ![image-20211004114845900](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041148946.png)

* 根据组内并行，组间并行的全加器的原理，我们可以进行ALU芯片的优化

  <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041150496.png" alt="image-20211004115030416" style="zoom:80%;" />

### 3.1 - 存储器芯片介绍

  1. 存储一个二进制位的方法（方法不唯一）：使用一个电容拼接上一个开关元件

     > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041323648.png" alt="image-20211004132307614" style="zoom:50%;" />
     >
     > 读操作：数据存储在电容中，当需要读取数据时，给开关元件一个读信号，开关元件收到信号后，控制整个电路连通，数据就可以沿着导线流到右端的数据寄存器当中
     >
     > 写操作：数据存储在右端的数据寄存器中，当需要存入数据时，给开关元件一个存储信号，开关元件收到信号后，控制整个电路连通，数据就可以沿着导线流到电容中，存储在电容上面
     >
     > ---
     >
     > 这样的能够完成一个二进制位读写的单元称作一个存储元

  2. 存储体：一个存储体是由多个存储元构成

     ![image-20211004132836780](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041328856.png)

     * 红色的线用于并行控制多个存储元，绿色的线用于传入或传出存储元上面的信号
     * 我们把存储元进行分组，同一组的全部存储元共同组成了一个存储单元
     * 我们把多个存储单元构成的矩阵称为存储体
     * 同一个存储单元上存储的电信号称为一个存储字，根据存储单元的不同，存储字的字长也会不同（一般字长都为8的整数倍）
     * 因为绿线一次只能读取一个存储单元上的存储字，所以在读取或写入的过程中必须保证有且**只有一个存储单元有效**（有红线信号），因为若是使用红线信号的每一位代表一个存储单元，无疑是十分浪费资源的。所以我们可以通过**译码器**来将n位地址映射到2^n^个存储单元上

  3. 主存储器的简单模型

     <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041341038.png" style="zoom:67%;" />

     ![image-20211004134027447](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041340614.png)

     * 地址线：MAR连接外部的信号线（n条地址 → 2^n^个存储单元）
     * 数据线：MDR连接外部的信号线
     * 片选线：整个芯片的开关（两种模式：高电平有效和低电平有效）
     * 读控制线、写控制线：用来决定当前需要执行的操作（有时候会被合并为一条读写控制线）

     <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041345454.png" alt="image-20211004134531408" style="zoom:67%;" />

  4. 存储体的容量问题：

     > n条地址线 → n位地址 → 2^n^个存储单元
     >
     > m条数据线 → 存储字长为m
     >
     > ---
     >
     > 总容量 = 存储单元个数 * 存储字长 = 2^n^ * m
     >
     > ![image-20211004134925688](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041349722.png)
     >
     > ---
     >
     > 常见的存储容量的描述：
     >
     > 8K × 8位 → 有8 × 2^10^个存储单元，每个存储单元的字长为8b → 2^3^ × 2^10^ × 8b → 8KB
     >
     > 8K × 1位 → 有8 × 2^10^个存储单元，每个存储单元的字长为1b → 2^3^ × 2^10^ × 1b → 1KB
     >
     > 64K × 16位 → 有64 × 2^10^个存储单元，每个存储单元的字长为16b  → 2^6^ × 2^10^ × 16b → 128KB

  ### 3.2 - 寻址

1. 寻址：定位到某一个存储单元

2. 分类：

   > 设总容量为1KB，每个**存储单元**有4B（这里的单元是表示将存储体分割为几块）
   >
   > * 按字节寻址：1K个单元，每个单元1B
   > * 按字寻址：256个单元，每个单元4B
   > * 按半字寻址：512个单元，每个单元2B
   > * 按双字寻址：128个单元，每个单元8B
   >
   > ---
   >
   > 字地址：每个单元的第一个字节的地址

3. 如何存放一个字：[大小端存储](#大小端模式)

   > * 大端存储：以高位字节为字地址
   > * 小端存储：以低位字节为字地址

### 3.3.1 - 半导体存储器RAM

> RAM（易失性存储器）：掉电后数据丢失，但是读写速度快

1. 半导体随机存储器

   |            |                          SRAM                          |                             DRAM                             |
   | :--------: | :----------------------------------------------------: | :----------------------------------------------------------: |
   |  存储信息  |                 利用触发器的双稳态存储                 |                     利用电容的充放电存储                     |
   | 破坏性读出 | **否**<br>读：查看触发器的状态<br>写：改变触发器的状态 |   **是**<br>读：连接电容，检测电流变化<br>写：给电容充放电   |
   |  需要刷新  |           否<br>触发器能够保持两种稳定的状态           |                是<br>电容上的电荷只能维持2ms                 |
   | 送行列地址 |                         同时送                         | 分两次送（将地址拆分为行地址和列地址）<br>使地址线复用，使用的地址线数减少一半 |
   |  运行速度  |                           快                           |                              慢                              |
   |   集成度   |                 低（需要6个逻辑元件）                  |                  高（需要1个或3个逻辑元件）                  |
   |   发热量   |                           大                           |                              小                              |
   |  存储成本  |                           高                           |                              低                              |
   |  使用场景  |                  常用作Cache（缓存）                   |                          常用作主存                          |

   > DRAM的送行列地址拆分的说明 —— 将地址由一维线性变为二维平面
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041422233.png" alt="image-20211004142203130" style="zoom:80%;" />

2. DRAM刷新

   > 1. 刷新时间：一般为2ms
   >
   > 2. 刷新以行为单位，每次刷新一行存储单元
   >
   >    采用行列地址的好处：减少选通线的数量
   >
   > 3. 刷新的实现原理：读出一行的信息后重新写入，占一个读/写周期，对于刷新由专门的硬件支持
   >
   > 4. 刷新模式：
   >
   >    > 在刷新周期内 —— 必须刷新完DRAM内部的所有行
   >    >
   >    > **分散刷新**：延长系统的读/写周期，每次读写后刷新某行
   >    >
   >    > **集中刷新**：不改变读/写周期，但是在刷新周期内专门留有一段时间用于刷新，这段时间内无法访问存储器，被称作“死区”
   >    >
   >    > **异步刷新**：把一个刷新周期平均分为需要刷新的次数段时间，每隔这段时间刷新一次，每段时间中有一个读/写周期的“死时间”
   >    >
   >    > > 异步刷新时间间隔的计算：时间 = 刷新周期 / 行数 
   >    >
   >    > 由容量扩充的时候，存储器中的所有芯片同时刷新

3. DRAM的存取周期

   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041856041.png" alt="image-20211004185640994" style="zoom: 50%;" />

   * 读周期

     ![image-20211004190934909](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041909987.png)

   * 写周期

     ![image-20211004191144269](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041911327.png)

### 3.3.2 - 半导体存储器ROM

> ROM（只读存储器）：写入速度慢（甚至一开始只能由制造商进行一次写操作），但是掉电不会丢失数据且能和CPU直接通信

1. 应用：

   > CPU的作用：从主存中获取指令，并按照指令的指示进行下一步操作
   >
   > 主存：是由RAM和ROM构成组成，且RAM和ROM都可以与CPU直接通信
   >
   > ---
   >
   > ROM的作用：因为RAM会因为掉电而丢失数据，所以在每次开机时，需要让CPU与ROM通信，将辅存中的OS数据调到RAM中
   >
   > ​						所以说，ROM的作用就是存储开机时的必要信息，与CPU直接通信，让CPU将辅存中的OS数据调到RAM中

2. 发展：

   ![image-20211004192516974](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041925103.png)

### 3.3.3 - 存储器基本概念

1. 分类：

   > 按作用层次分类：
   >
   > * 主存储器（主存、内存）：能与CPU直接通信
   > * 高速缓冲存储器（缓存）：离CPU最近，用于系统性能提升
   > * 辅助存储器（辅存、外存）：不能与CPU直接通信，属于外设
   >
   > ![image-20211004193303339](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041933412.png)

   > 按照材料分类：
   >
   > * 磁表面存储器：磁带，磁盘
   > * 磁芯存储器
   > * 半导体存储器：ROM、RAM
   >
   > * 光存储器：光盘

   > 按照存储方式分类：
   >
   > * 随机存取：存取时间与位置无关 → 半导体存储器
   > * 顺序存取：存取时间与数据存储的位置有关 → 磁带
   > * 直接存取：先定位到一个小区域，在这个区域之间进行顺序存取 → 磁盘

   > 按照信息的可保存性：
   >
   > * 易失性：RAM，通过电路结构保留
   > * 非易失性：除RAM之外的，通过物理原理保存信息
   >
   > 按照是否破坏性读出：
   >
   > * 破坏性读出：DRAM
   > * 非破坏性读出：其它

   ![image-20211004194037732](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041940853.png)

2. 作用：存储二进制信息

3. 性能指标：

   > * 存储容量 ： 存储字数 × 存储字长
   >
   > * 单位成本：总成本 / 总容量
   >
   > * 存储速度：数据传输率 = 数据的宽度 / 存储周期 （数据传输率又称主存带宽，表示每秒从主存进出信息的最大数量）
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041943354.png" alt="image-20211004194354308" style="zoom:67%;" />
   >
   >   

4. 层次化结构

   ![image-20211004194730085](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041947171.png)

### 3.4 - 存储器与CPU的连接

1. 存储器与CPU接口的介绍：

   > 存储器：<img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042007900.png" alt="image-20211004200745859" style="zoom:67%;" />
   >
   > n条地址线 → n位地址 → 2^n^个存储单元
   >
   > m条数据线 → 存储字长为m
   >
   > ---
   >
   > CPU：<img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042008144.png" alt="image-20211004200859097" style="zoom:67%;" />

2. 主存容量扩展 - 位扩展 → 解决CPU与存储器数据线不匹配问题（扩展字长）

   > ![image-20211004201325981](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042013053.png)
   >
   > 每个扩展的芯片连接一个CPU的数据线，而它们共享CPU的地址线信号

3. 译码器的介绍：使用n根地址线，控制2^n^个存储器（连接片选线的接口）

   > ![image-20211004201625324](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042016447.png)

4. 主存容量扩展 - 字扩展 → 使CPU连接更多的存储器，并通过固定位上CPU地址线信号的不同，从而控制不同的存储器（扩展存储单元）

   > * 线选法：
   >
   >   ![image-20211004202428988](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042024143.png)
   >
   >   > 将A~13~与A~14~的数据，用作指定两个不同的存储器分别工作（因为存储器共用同一组数据线，所以只能有一个在工作）
   >
   > * 译码片选法：
   >
   >   ![image-20211004202918181](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042029336.png)
   >
   >   > 使用译码器来指定存储器的工作状态：提升了（n条）地址线的控制效率【 从n到2^n^ 】
   >
   > ![image-20211004203125797](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042031864.png)

5. 主存容量扩展 - 字位同时扩展

   ![image-20211004203253923](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042032030.png)

6. [例题](https://www.bilibili.com/video/BV1BE411D7ii?p=64)

   > 解题步骤：确认地址线、数据线、存储器芯片
   >
   > * 数据线：CPU的数据线条数 → 若没有对应条数的存储器芯片，那么需要把存储器芯片位扩展
   >
   > * 地址线：根据地址空间分配换算存储器的存储单元个数（将地址空间转换为2进制即可表示存储单元的个数）
   >
   >   ​				再通过存储单元的个数换算地址线的数量 → 转换为地址线的信号位数
   >
   >   ​				最后再分配地址信号、选片信号（译码器的输入信号）和译码器使能端信号
   >
   > * 存储器芯片：在分配数据线的时候就需要选定，然后还需要注意 —— 系统程序区用ROM、用户程序区用RAM

### 3.5 - 双口RAM和多模块存储器

> 根据摩尔定律，CPU的速度和主存的容量都是指数级增长，而主存的速度是线性增长
>
> 所以如何处理主存的速度，变成了计算机优化的一大主题。
>
> 其中一个方案就是提高主存本身的存储速度。
>
> 存取周期：是对存储器的两个存取操作的时间间隔，一次存取周期可以是总线传输周期的n倍
>
> <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110041943354.png" alt="image-20211004194354308" style="zoom:67%;" />
>
> 总线传输周期：传送一次数据总线上的数据所花时间

* 双口RAM存储器（了解）

  ![image-20211004231516410](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042315532.png)

* 多模块存储器（重点）

  1. 实现方案：

     ![image-20211004231952464](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042319587.png)

  2. 多体并行存储器的工作模式：

     ![image-20211004232222910](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042322025.png)

     

     > 在连续读取n个存储字的情况下，设每个存储体的存储周期为T
     >
     > * 高位交叉编址的多体存储器：相当于主存容量的字扩展，并不会有读取速度的优化
     >
     >   ![image-20211004233354209](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042333257.png)
     >
     >   连续读取n个存储字耗时：nT
     >
     > * 低位交叉编制的多体存储器：相当于在存储器的恢复时间，存取了其它存储器的数据，相当于减少了存储器的恢复时间
     >
     >   ![image-20211004234911770](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110042351269.png)
     >
     >   我们设模块数为m，存储周期为T，总线传输周期为τ（每隔τ个时间启动下一个存储体）
     >
     >   ---
     >
     >   若 **m >= T / τ** ，说明在地址存取完”一行“后，”下一行“的首个存储体已经经过了一个存取周期，可以无需等待恢复时间，直接进行下一次存取 —— 则有连续读取n个存储字耗时：**T + (n - 1) × τ**
     >
     > * 带宽问题（当n较大时）：证明见下方计算题
     >
     >   > 低位交叉编制的多体存储器的带宽 = 字长 / 总线传输周期
     >   >
     >   > 单个存储体的带宽 = 字长 / 存取周期

  3. 考点：

     > * 微观计算题：
     >
     >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110050001885.png" alt="image-20211005000103809" style="zoom:67%;" />
     >
     > * 宏观概念题：
     >
     >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110050002806.png" alt="image-20211005000206768" style="zoom:67%;" />

### 3.6.1 -  局部性原理

> 根据摩尔定律，CPU的速度和主存的容量都是指数级增长，而主存的速度是线性增长
>
> 所以如何处理主存的速度，变成了计算机优化的一大主题。
>
> 还有一个根据程序访问的局部性原理，改进为”Cache - 主存“的层次化理念

1. 局部性原理

   > 空间局部性：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是临近的
   >
   > 时间局部性：在最近的未来要用到的信息，很可能就是现在正在使用的信息

2. **Cache - 主存**层次优化

   > 未优化前：CPU直接到主存中存取数据，而因为主存中存取数据的时间远大于CPU处理数据的时间，而且CPU读取主存中的数据只能获取指定的一个数据，所以需要浪费大量的时间在主存存取数据上
   >
   > 优化：在CPU存取主存数据时，主存会将与该数据相邻的一块数据全部存放在Cache中，之后CPU再需要访问与之前读取数据临近的数据，就可以直接到Cache中读取
   >
   > 优化后：因为Cache的存取速率远高于主存，所以CPU可以很快地存取Cache中的数据，这样就不会在主存存取数据上浪费时间

3. 优化性能分析

   > * 概念补充：
   >
   >   1. 命中率H：CPU欲访问的信息在Cache中的比率
   >
   >      > 设一个程序执行其间，Cache的总名字次数为N~c~，访问主存的总次数为N~m~
   >      >
   >      > 则 H = N~c~ / ( N~c~ + N~m~ )
   >
   >   2. 命中缺失率M：M = 1 - H
   >
   >   3. 平均访问时间T~a~
   >
   >      > 设t~c~为命中时的Cache访问时间，t~m~为未命中时的访问时间
   >      >
   >      > T~a~ = HT~c~ + (1 - H) t~m~
   >
   > * 例题：
   >
   >   ![image-20211005114006809](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051140023.png)
   >
   >   而系统的效率计算方式为：平均时间 / 命中率100%Cache的访问时间

### 3.6.2 - Cache的地址映射方式

1. Cache的工作原理

   > 1. 主存中的块在Cache中的存放位置：地址映射
   >
   >    > * 全相联映射：空位随意放
   >    > * 直接映射：对号入座
   >    > * 组相联映射：按号分组，组内随意放
   >
   > 2. 若空位被占用了的处理方法：替换算法
   >
   >    > * 随机（RAND）算法
   >    > * 先进先出（FIFO）算法
   >    > * 删除近期较少使用（LRU）算法
   >    > * 删除最不经常使用（LFU）算法
   >
   > 3. 在CPU通过指令修改内容后，保证主存和Cache数据统一的方法：写策略
   >
   >    > 命中：
   >    >
   >    > * 全写法（write-through）
   >    > * 写回法（write-back）
   >    >
   >    > 不命中：
   >    >
   >    > * 写分配法（write-allocate）
   >    > * 非写分配法（not-write-allocate）

2. 地址映射

   #TODO

   > * 全相联映射：空位随意放
   >
   >   将主存的地址分为两块内容：主存字块标记（绿色 + 蓝色） + 字块内地址
   >
   >   > 黑色的字块内地址与每个Cache块的大小一一对应
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051508552.png" alt="image-20211005150830472" style="zoom:67%;" />
   >
   >   ---
   >
   >   在将主存数据放入Cache中时，不仅需要将数据存放到Cache中，还需要创建数据的标记项 —— **有效位 + 主存字块标记**，有效位用来区分Cache中是否存有数据，主存字块标记用于区分该行来自于主存的哪一块（同时使用蓝绿两种颜色是因为它们的数据在Cache中都不可控，可控的数据不需要传递给Cache）
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051512852.png" alt="image-20211005151223764" style="zoom:67%;" />
   >
   > * 直接映射：对号入座
   >
   >   将主存的地址分为两块内容：主存字块标记（绿色）+Cache字块地址（蓝色） + 字块内地址
   >
   >   > 蓝色的地址与Cache中的块数一一对应
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051517549.png" alt="image-20211005151743467" style="zoom:67%;" />
   >
   >   ---
   >
   >   Cache中的标记项需要包含 —— **有效位 + 主存字块标记**，因为Cache中的数据存放是有序的，所以绿色的Cache字块内地址是可控的，所以只需要传递蓝色的主存字块标记
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051516303.png" alt="image-20211005151600215" style="zoom:67%;" />
   >
   >   
   >
   > * 组相联映射：按号分组，组内随意放
   >
   >   将主存的地址分为两块内容：主存字块标记（蓝色 + 绿色）+组地址（紫色） + 字块内地址
   >
   >   > 紫色的地址与Cache中的组数一一对应
   >
   >   <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051527478.png" alt="image-20211005152722398" style="zoom:67%;" />
   >
   >   ---
   >
   >   Cache中采用X路组相联，即相当于把Cache分为X组。主存中的数据需要保存到对应组号的Cache块中，除此之外，还需要保存标记项。Cache中的标记项需要包含 —— **有效位 + 主存字块标记**，因为需要保存的组号（组地址）在Cache中是可控的，所以只需要传递绿色和蓝色的主存字块标记即可
   >
   > * ![image-20211005153216339](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051532429.png)
   >
   >   可以通过Cache中某行的标记项找到改行在主存中的对应数据
   >
   > * 相联存储器：
   >
   >   根据映射到的Cache块号比较标记，若标记为1，则命中；若标记不同，则直接替换

3. 替换算法：

   > 1. 随机算法（RAND）：随机地确定替换的Cache块，实现简单，但没有考虑局部性原理，所以命中率较低（一般不考）
   >
   > 2. 先进先出算法（FIFO）：选择最早调入的行进行替换，实现较为交单，但同样没有考虑局部性原理，所以命中率较低
   >
   > 3. 近期最少使用算法（LRU）：选择最后一次使用时间最早的Cache块进行替换
   >
   >    > 对每行设置一个计数器，Cache每命中一次，命中的行计数器清0，其它行计数器+1。在替换时，选择计数器最大的行进行替换
   >
   > 4. 最不经常使用算法（LFU）：选择一段时间内访问最少的Cache块进行替换
   >
   >    > 对每行设置一个计数器，每访问一次，计数器+1。。在替换时，选择计数器最小的行进行替换
   >
   > ---
   >
   > * 全相联映射的替换算法：
   >
   >   ![image-20211005154733298](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051547513.png)
   >
   >   > LRU算法手算策略：
   >   >
   >   > 1. 标记已经命中的块
   >   > 2. 从后向前寻找，遇到被标记的块，就划掉前面所有与被标记相同的块
   >   > 3. 最后找到的块即为被替换的块
   >
   >   > LRU算法手算策略：
   >   >
   >   > 1. 将所有块被命中的次数记录下来，找到被命中次数最少的块
   >   > 2. 若被命中次数最少的块有多个，则需要参考操作系统的知识进行判断（所以不常考）
   >
   > * 直接映射的替换方法：
   >
   >   > 将主存地址块号对Cache的块数取余，取余的结果就是该数据之后需要放入的地址
   >   >
   >   > 将主存地址块号对Cache的块数求商，求商的结果就是该数据对应的标记位
   >   >
   >   > （标记位相同，有效位为1 → 命中	| 	标记位不同，有效位为1 → 替换）
   >
   >   ![image-20211005160542789](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051605975.png)
   >
   >   > 这里的替换算法就是若标记位不同而有效位为1，则发生替换，改变标记位
   >
   > * 组相联方式的替换方法：
   >
   >   > 步骤：
   >   >
   >   > 1. 将Cache分组
   >   > 2. 使用主存的地址块号 % Cache的块数，得到对应数据应该存放的组号
   >   > 3. 使用主存的地址块号 / Cache的块数，得到对应数据的标记
   >
   >   ![image-20211005164250499](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051642650.png)
   >
   >   > 这里的替换方法与全相联映射的替换算法一致，需要分类讨论进行替换
   >
   > ---
   >
   > 解题格式：直接写入访问流
   >
   > ![image-20211005164355317](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110051643519.png)

4. 写策略（理解）

   > * 写回法（已命中）：
   >
   >   > 在Cache的标记项中添加一位数据位记录Cache中的数据是否被写入更改，我们把这个数据位称作脏位
   >   >
   >   > 在Cache中数据被覆盖时，检查脏位数据，若脏位数据显示被该数据被改变，则需要将该数据写入主存
   >
   > * 全写法（已命中）：
   >
   >   > 在更改Cache数据时，通过更改主存的是数据
   >   >
   >   > 因为主存的读入速度较慢，所以通常会使用写缓冲（Cache将数据读入写缓冲中，然后CPU就能继续访问Cache，再由写缓冲将数据写入主存）
   >
   > * 写分配法（未命中）：搭配写回法使用
   >
   >   > 将主存中未命中的部分直接调入Cache，在Cache中使用写回法修改（添加脏位）
   >
   > * 非写分配法（未命中）：搭配全写法使用
   >
   >   > 直接在主存中写入，搭配全写法使用
   >
   > <img src="https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110052020332.png" alt="image-20211005202040262" style="zoom:67%;" />
   >
   > ---
   >
   > * 联合使用
   >
   >   ![image-20211005202144898](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110052021962.png)

5. [例题](https://www.bilibili.com/video/BV1BE411D7ii?p=69&spm_id_from=pageDriver)

   ![image-20211005234118047](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110052341157.png)

6. Cache工作原理图：

   ![image-20211005233829729](https://hikki-library.oss-cn-shenzhen.aliyuncs.com/img/202110052338814.png)

### 3.6.3 - 虚拟存储器



